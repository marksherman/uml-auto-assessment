/*
 *	This file is part of Dereferee, the diagnostic checked pointer library.
 *
 *	Dereferee is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation; either version 2 of the License, or
 *	(at your option) any later version.
 *
 *	Dereferee is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with Dereferee; if not, write to the Free Software
 *	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#ifndef DEREFEREE_LISTENER_H
#define DEREFEREE_LISTENER_H

#include <cstdarg>
#include <climits>
#include <memory>
#include <typeinfo>

#include <dereferee/option.h>
#include <dereferee/platform.h>

// ===========================================================================

namespace Dereferee
{

class listener;
class allocation_info;
class usage_stats;


// ===========================================================================
/**
 * These are the possible error codes generated by Dereferee. Typically a
 * listener will create an array of strings representing human-readable
 * messages for these errors, and use the error code as an index into this
 * array.
 * 
 * Error codes are passed by number rather than passing a message directly
 * in the event that a custom listener would like to perform another kind
 * of data collection; in this case, it may be more useful to have the
 * number to use as a key into some record structure.
 */
enum error_code
{
	/* Checked pointers cannot point to memory that wasn't allocated with
	 * new or new[] */
	error_assign_non_new = 0,

	/* Assigned dead (never initialized) pointer to another pointer */
	error_assign_dead_uninitialized,
	
	/* Assigned dead (already deleted) pointer to another pointer */
	error_assign_dead_deleted,
	
	/* Assigned dead (out of bounds) pointer to another pointer */
	error_assign_dead_out_of_bounds,

	/* Called delete instead of delete[] on array pointer */
	error_nonarray_delete_on_array,
	
	/* Called delete[] instead of delete on non-array pointer */
	error_array_delete_on_non_array,
	
	/* Called delete on (never initialized) dead pointer */
	error_nonarray_delete_dead_uninitialized,

	/* Called delete[] on (never initialized) dead pointer */
	error_array_delete_dead_uninitialized,

	/* Called delete on (already deleted or not dynamically allocated)
	 * dead pointer */
	error_nonarray_delete_dead_deleted,
	
	/* Called delete[] on (already deleted or not dynamically allocated)
	 * dead pointer */
	error_array_delete_dead_deleted,

	/* Dereferenced (never initialized) dead pointer using operator-> */
	error_deref_uninitialized_arrow_op,
	
	/* Dereferenced (never initialized) dead pointer using operator* */
	error_deref_uninitialized_star_op,

	/* Dereferenced (never initialized) dead pointer using operator[] */
	error_deref_uninitialized_index_op,

	/* Dereferenced (already deleted) dead pointer using operator-> */
	error_deref_deleted_arrow_op,
	
	/* Dereferenced (already deleted) dead pointer using operator* */
	error_deref_deleted_star_op,

	/* Dereferenced (already deleted) dead pointer using operator[] */
	error_deref_deleted_index_op,

	/* Dereferenced (out of bounds) dead pointer using operator-> */
	error_deref_out_of_bounds_arrow_op,
	
	/* Dereferenced (out of bounds) dead pointer using operator* */
	error_deref_out_of_bounds_star_op,

	/* Dereferenced (out of bounds) dead pointer using operator[] */
	error_deref_out_of_bounds_index_op,

	/* Dereferenced null pointer using operator-> */
	error_deref_null_arrow_op,

	/* Dereferenced null pointer using operator* */
	error_deref_null_star_op,

	/* Dereferenced null pointer using operator[] */
	error_deref_null_index_op,

	/* Converted (never initialized) dead pointer back to a raw pointer in an
	 * expression */
	error_used_dead_uninitialized,
	
	/* Converted (already deleted) dead pointer back to a raw pointer in an
	 * expression */
	error_used_dead_deleted,
	
	/* Converted (out of bounds) dead pointer back to a raw pointer in an
	 * expression */
	error_used_dead_out_of_bounds,

	/* Used (never initialized) dead pointer in a comparison */
	error_compare_dead_uninitialized,
	
	/* Used (already deleted) dead pointer in a comparison */
	error_compare_dead_deleted,
	
	/* Used (out of bounds) dead pointer in a comparison */
	error_compare_dead_out_of_bounds,
	
	/* Used null pointer on only one side of an inequality comparison;
	 * if one side is null then the both sides must be null */
	error_inequality_one_side_null,
	
	/* Both pointers being compared are alive but point into different
	 * memory blocks, so the comparison is undefined */
	error_relational_different_blocks,

	/* Used (never initialized) dead pointer in an arithmetic expression */
	error_arithmetic_dead_uninitialized,
	
	/* Used (already deleted) dead pointer in an arithmetic expression */
	error_arithmetic_dead_deleted,
	
	/* Used (out of bounds) dead pointer in an arithmetic expression */
	error_arithmetic_dead_out_of_bounds,
	
	/* Used null pointer in an arithmetic expression */
	error_arithmetic_null,
	
	/* Used null pointer on only one side of a pointer subtraction expression;
	 * if one side is null then both sides must be null */
	error_subtraction_one_side_null,

	/* Both pointers being subtracted are alive but point into different
	 * memory blocks, so the distance between them is undefined */
	error_subtraction_different_blocks,
	
	/* Pointer arithmetic has moved a live pointer out of bounds */
	error_arithmetic_moved_out_of_bounds,

	/* Used operator[] on a pointer that does not point to an array */
	error_index_non_array,
	
	/* Array index "index" is out of bounds; valid indices are in the range
	 * [0.."upper_bound"]
	 * 
	 * Extra arguments: index (int), upper_bound (size_t) */
	error_index_out_of_bounds,
	
	/* A previous operation has made this pointer invalid */
	error_pointer_not_found
};


// ===========================================================================
/**
 * These are the warning codes generated by Dereferee. Their usage is similar
 * to the error codes described above.
 */
enum warning_code
{
	/* Memory leak caused by last live pointer to memory block going out of
	 * scope */
	warning_live_pointer_out_of_scope = 0,

	/* Memory leak caused by last live pointer to memory block being
	 * overwritten */
	warning_live_pointer_overwritten,
	
	/* Memory before and/or after allocated block was corrupted, likely due
	 * to invalid array indexing or pointer arithmetic
	 * 
	 * Extra arguments: location (memory_corruption_location) */
	warning_memory_boundary_corrupted
};


// ===========================================================================
/**
 * This enumeration describes the possible values that can be passed along
 * with the warning_block_boundary_corrupted warning code to indicate which
 * side of the memory block was corrupted.
 */
enum memory_corruption_location
{
	memory_corruption_none = 0,
	memory_corruption_before = 1,
	memory_corruption_after = 2,
	memory_corruption_both = 
		memory_corruption_before | memory_corruption_after
};


// ===========================================================================
/*
 * USING A CUSTOM LISTENER WITH DEREFEREE
 *
 * If you wish to use a listener other than one of those provided in this
 * package, then you must implement a subclass of Dereferee::listener as well
 * as the following two functions, which are called when the Dereferee manager
 * is created and destroyed, respectively, in order to initialize the listener.
 * This allows clients to customize the notification behavior of Dereferee
 * by linking in a different listener implementation, without requiring any
 * modification to client code using the library.
 *
 * Since the listener class is used internally by the Dereferee memory manager,
 * you should refrain from using the new/delete operators in a custom listener
 * that you write. A listener method can be called in the context of the
 * global new/delete operators, which could cause infinite recursion. This
 * implies that using STL containers is unsafe; instead, prefer managing
 * memory using the C functions malloc(), calloc(), realloc() and free(), if
 * necessary. If you absolutely must use any STL containers, then use custom
 * allocators to ensure that they don't use new/delete.
 *
 * The exception to this rule is when creating the listener itself; since the
 * listener abstract base class overloads the class new/delete operators to
 * bypass Dereferee's tracking versions, you can safely use new/delete to
 * create/destroy the listener.
 */

// ---------------------------------------------------------------------------
/**
 * Creates a new listener object that will be notified of various memory and
 * pointer-related events by the Dereferee memory manager.
 *
 * @param options an array of options to pass to the listener; the last entry
 *     in this array contains NULL in the key and value fields
 * @param platform a pointer to the object that represents the platform under
 *     which Dereferee is executing. This can be used by the listener to
 *     print the backtraces acquired during allocation or when errors occur
 * 
 * @returns a pointer to the newly created listener object
 */
extern listener* create_listener(const option* options, platform* platform);

// ---------------------------------------------------------------------------
/**
 * Releases any resources associated with the specified listener.
 *
 * @param listener the listener to be destroyed
 */
extern void destroy_listener(listener* listener);


// ===========================================================================
/**
 * This abstract base class represents the interface used by Dereferee to
 * send notifications about memory usage to a listener object.  Implementors
 * should derive their custom listener from this class if they wish to provide
 * different behavior than the default.
 */
class listener
{
public:
	virtual ~listener() { }

    // -----------------------------------------------------------------------
    /**
     * Called each time a memory allocation is made so that the listener can
     * associate an arbitrary listener-specific value with the memory block.
     * At the time this method is called, the following properties in
     * allocation_info are valid: address, is_array, block_size, and
     * backtrace. The properties array_size and type_name are NOT valid at
     * the time this method is called.
     *
     * The value returned from this method can be either a scalar value cast
     * to void*, or a block of dynamically allocated memory (which you must
     * free in free_allocation_user_info). If this method allocates memory,
     * it should use malloc and free to manage that memory; under no
     * circumstances should new/delete be used.
     * 
     * @param alloc_info an allocation_info reference describing properties of
     *     the allocated memory block
     *
     * @returns an arbitrary value to associate with the memory block
     */
    virtual void* get_allocation_user_info(const allocation_info& alloc_info)
    {
        return NULL;
    }

    // -----------------------------------------------------------------------
    /**
     * Called each time a block of memory is freed so that the listener can
     * release any resources that it associated with the block in an earlier
     * invocation of get_allocation_user_info (accessible by calling the
     * user_info() method on alloc_info).
     * 
     * @param alloc_info an allocation_info reference describing properties of
     *     the allocated memory block
     *
     * @returns an arbitrary value to associate with the memory block
     */
    virtual void free_allocation_user_info(const allocation_info& alloc_info)
    {
    }

	// -----------------------------------------------------------------------
	/**
	 * Returns the maximum number of memory leaks that should be reported to
	 * the listener. If there are more leaks, then report_truncated() is called
	 * to report the actual number.
	 *
	 * The default implementation returns UINT_MAX.
	 *
	 * @returns the maximum number of memory leaks to report, or UINT_MAX to
	 *     effectively set no limit on the number of leaks reported
	 */
	virtual size_t maximum_leaks_to_report()
	{
        return UINT_MAX;
	}

	// -----------------------------------------------------------------------
	/**
	 * Called by the memory manager to notify the listener that the end-of-
	 * execution memory usage report is about to begin. This call will be
	 * followed by zero or more calls to report_leak(), then by zero or one
	 * call to report_truncated(), and then a call to end_report().
	 *
	 * The default implementation does nothing.
	 *
	 * @param stats a usage_stats object that can be queried for information
	 *     about memory usage during program execution
	 */
	virtual void begin_report(const usage_stats& stats)
	{
	}
	
	// -----------------------------------------------------------------------
	/**
	 * Called by the memory manager to ask whether this allocation, left over
	 * at the end of the program, is actually a leak. By default, this method
	 * will always return true; a listener can override it if it wishes to
	 * use custom logic to filter out certain "leaks".
	 *
	 * @param leak an allocation_info object that can be queried for
	 *     information about the block of memory that was leaked
	 */
	virtual bool should_report_leak(const allocation_info& leak)
	{
        return true;
	}

	// -----------------------------------------------------------------------
	/**
	 * Called by the memory manager to report that a block of memory was
	 * leaked at the end of program execution.
	 *
	 * The default implementation does nothing.
	 *
	 * @param leak an allocation_info object that can be queried for
	 *     information about the block of memory that was leaked
	 */
	virtual void report_leak(const allocation_info& leak)
	{
	}

	// -----------------------------------------------------------------------
	/**
	 * Called by the memory manager if the number of actual leaks is greater
	 * than the number returned from max_leaks_to_report().
	 *
	 * The default implementation does nothing.
	 *
	 * @param leaks_logged the number of leaks that were actually reported
	 * @param actual_leaks the actual number of total leaks that occurred
	 */
	virtual void report_truncated(size_t leaks_reported,
								  size_t actual_leaks)
	{
	}

	// -----------------------------------------------------------------------
	/**
	 * Called by the memory manager to notify the listener that the end-of-
	 * execution memory usage report is complete.
	 *
	 * The default implementation does nothing.
	 */
	virtual void end_report()
	{
	}

	// -----------------------------------------------------------------------
	/**
	 * This method is called by the memory manager to notify the listener that
	 * a fatal error has been caused by incorrect use of a checked pointer or
	 * a block of memory.  An error is considered fatal if it would result in
	 * undefined behavior, such as a segmentation fault or nondeterministic
	 * behavior at runtime).
	 *
	 * @param code the error code indicating what occurred
	 * @param args a varargs list that contains arguments to be used when
	 *     formatting the error message string
	 */
	virtual void error(error_code code, va_list args) = 0;

	// -----------------------------------------------------------------------
	/**
	 * This method is called by the memory manager to notify the listener of
	 * a warning caused by incorrect use of a checked pointer or a block of
	 * memory. Warnings are defined as situations that do not immediately
	 * result in undefined behavior or runtime failure, but that are likely
	 * to lead to such behavior in the future. Memory leaks also fall into
	 * this category.
	 *
	 * @param code the warning code indicating what occurred
	 * @param args a varargs list that contains arguments to be used when
	 *     formatting the warning message string
	 */
	virtual void warning(warning_code code, va_list args) = 0;
	
	// -----------------------------------------------------------------------
	/**
	 * Override the class-specific allocator and deallocator methods so that
	 * the creation of listener subclasses will not interfere with the memory
	 * tracking in the global operators.
	 */
	void* operator new(size_t size) { return malloc(size); }
	void operator delete(void* ptr) { free(ptr); }
};


// ===========================================================================
/**
 * This interface is used by the report_leak() method of a listener so that
 * the listener can obtain information about the memory that was leaked.
 *
 * This interface is not intended to be implemented by users.
 */
class allocation_info
{
public:
	virtual ~allocation_info() { }

	// -----------------------------------------------------------------------
	/**
	 * Returns the address of the block of memory.
	 *
	 * @returns the memory address
	 */
	virtual const void* address() const = 0;
	
	// -----------------------------------------------------------------------
	/**
	 * Returns the size, in bytes, of the block of memory.
	 *
	 * @returns the size of the memory block, in bytes
	 */
	virtual size_t block_size() const = 0;
	
	// -----------------------------------------------------------------------
	/**
	 * Gets a value indicating whether or not the block of memory allocated
	 * was for an array.
	 *
	 * @returns true if the memory was allocated with new[]; false if it was
	 *     allocated with new
	 */
	virtual bool is_array() const = 0;
	
	// -----------------------------------------------------------------------
	/**
	 * If the block of memory was allocated as an array, gets the number of
	 * elements allocated for that array.
	 *
	 * @returns the number of elements in the array
	 */
	virtual size_t array_size() const = 0;
	
	// -----------------------------------------------------------------------
	/**
	 * Gets the implementation-defined string representation of the type of
	 * object(s) that was/were allocated. Specifically, if this block of memory
	 * was allocated by a call to "new T" or "new T[]", then this method
	 * returns the value typeid(T).name().
	 * 
	 * It is the responsibility of the listener to convert this into a human-
	 * readable form before displaying it, usually by asking the platform to
	 * demangle it if necessary.
	 *
	 * @returns the type name of objects in this memory block, or NULL if this
	 *     information is unavailable
	 */
	virtual const char* type_name() const = 0;
	
	// -----------------------------------------------------------------------
	/**
	 * Gets the backtrace that indicates the location and context in which
	 * this memory block was allocated.
	 *
	 * @returns the backtrace for the allocation of this memory block
	 */
	virtual void** backtrace() const = 0;
	
	// -----------------------------------------------------------------------
	/**
	 * Gets the listener-specific user info value that was associated with
	 * the memory block in a call to listener::get_allocation_user_info().
	 *
	 * @returns the listener-specific user info value of this memory block
	 */
    virtual void* user_info() const = 0;
    
    // -----------------------------------------------------------------------
    /**
     * Sets the listener-specific user info value that is associated with
     * the memory block. This can be used from a visitor function to update
     * the user info at a time other than when the block is first allocated.
     *
     * @param value the new user info value for the memory block
     */
    virtual void set_user_info(void* value) = 0;
};


// ---------------------------------------------------------------------------
/**
 * The signature of an allocation visitor function:
 * void my_allocation_visitor(allocation_info& alloc_info, void* arg);
 */
typedef void (* allocation_visitor)(allocation_info&, void*);


// ===========================================================================
/**
 * This interface is used by the begin_report() method of a listener so that
 * the listener can obtain information about general memory usage statistics,
 * such as the amount of memory in use, the number of calls to the various
 * memory allocation/deallocation operators, and the number of memory leaks
 * that occurred.
 *
 * This interface is not intended to be implemented by users.
 */
class usage_stats
{
public:
	virtual ~usage_stats() { }

	// -----------------------------------------------------------------------
	/**
	 * Gets the total number of blocks of memory that were leaked at the end
	 * of program execution.
	 *
	 * @returns the total number of memory leaks
	 */
	virtual size_t leaks() const = 0;
	
	// -----------------------------------------------------------------------
	/**
	 * Gets the total number of bytes of memory that were allocated during
	 * program execution. This value is the sum of all allocations that were
	 * made over the entire course of the program.
	 *
	 * @returns the total number of bytes allocated
	 */
	virtual size_t total_bytes_allocated() const = 0;
	
	// -----------------------------------------------------------------------
	/**
	 * Gets the maximum number of bytes of memory that were in use at any
	 * particular point in time during program execution. This value is a
	 * local maximum over time.
	 *
	 * @returns the maximum number of bytes in use at any one time during
	 *     execution
	 */
	virtual size_t maximum_bytes_in_use() const = 0;
	
	// -----------------------------------------------------------------------
	/**
	 * Gets the number of calls to operator new that were made during program
	 * execution.
	 *
	 * @returns the number of calls to operator new
	 */
	virtual size_t calls_to_new() const = 0;

	// -----------------------------------------------------------------------
	/**
	 * Gets the number of calls to operator new[] that were made during
	 * program execution.
	 *
	 * @returns the number of calls to operator new[]
	 */
	virtual size_t calls_to_array_new() const = 0;

	// -----------------------------------------------------------------------
	/**
	 * Gets the number of calls to operator delete with a non-null argument
	 * that were made during program execution.
	 *
	 * @returns the number of calls to operator delete with a non-null
	 *     argument
	 */
	virtual size_t calls_to_delete() const = 0;

	// -----------------------------------------------------------------------
	/**
	 * Gets the number of calls to operator delete[] with a non-null argument
	 * that were made during program execution.
	 *
	 * @returns the number of calls to operator delete[] with a non-null
	 *     argument
	 */
	virtual size_t calls_to_array_delete() const = 0;

	// -----------------------------------------------------------------------
	/**
	 * Gets the number of calls to operator delete with a null argument that
	 * were made during program execution.
	 *
	 * @returns the number of calls to operator delete with a null argument
	 */
	virtual size_t calls_to_delete_null() const = 0;

	// -----------------------------------------------------------------------
	/**
	 * Gets the number of calls to operator delete[] with a null argument that
	 * were made during program execution.
	 *
	 * @returns the number of calls to operator delete[] with a null argument
	 */
	virtual size_t calls_to_array_delete_null() const = 0;
};


} // namespace Dereferee


#endif // DEREFEREE_LISTENER_H
