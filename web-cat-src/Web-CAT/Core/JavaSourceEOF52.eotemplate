#*
   EO Template for use by the Velocity EOGenerator built into WOLips.
   BE SURE NOT TO INCLUDE DATES IN THIS FILE.
*#/*==========================================================================*\
 |  ${entity.prefixClassNameWithoutPackage}.java
 |*-------------------------------------------------------------------------*|
 |  Created by eogenerator
 |  DO NOT EDIT.  Make changes to ${entity.classNameWithoutPackage}.java instead.
 |*-------------------------------------------------------------------------*|
 |  Copyright (C) 2006-2012 Virginia Tech
 |
 |  This file is part of Web-CAT.
 |
 |  Web-CAT is free software; you can redistribute it and/or modify
 |  it under the terms of the GNU Affero General Public License as published
 |  by the Free Software Foundation; either version 3 of the License, or
 |  (at your option) any later version.
 |
 |  Web-CAT is distributed in the hope that it will be useful,
 |  but WITHOUT ANY WARRANTY; without even the implied warranty of
 |  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 |  GNU General Public License for more details.
 |
 |  You should have received a copy of the GNU Affero General Public License
 |  along with Web-CAT; if not, see <http://www.gnu.org/licenses/>.
\*==========================================================================*/

#if ($entity.superclassPackageName)
package $entity.superclassPackageName;

#end
import com.webobjects.eoaccess.*;
import com.webobjects.eocontrol.*;
import com.webobjects.foundation.*;
import er.extensions.eof.ERXEOControlUtilities;
import er.extensions.eof.ERXKey;
import org.apache.log4j.Logger;
import org.webcat.core.EOBasedKeyGenerator;
import org.webcat.woextensions.WCFetchSpecification;

// -------------------------------------------------------------------------
/**
 * An automatically generated EOGenericRecord subclass.  DO NOT EDIT.
 * To change, use EOModeler, or make additions in
 * ${entity.classNameWithoutPackage}.java.
 *
 * @author Generated by eogenerator
 * @version version suppressed to control auto-generation
 */
#*
   This is how to put in a custom EO superclass.  We also declare
   this class as being abstract, since it should never be instantiated.
*#public abstract class ${entity.prefixClassNameWithoutPackage}
    extends #if ($entity.parentSet)${entity.parent.className}
#{else}org.webcat.core.EOBase
#end
#set ($alreadyFoundMutableAttribute = false)
#foreach ($attribute in $entity.sortedClassAttributes)
#if ($attribute.userInfo.isMutable && !$alreadyFoundMutableAttribute)
    implements org.webcat.core.MutableContainer.MutableContainerOwner
#set ($alreadyFoundMutableAttribute = true)
#end
#end
#set ($alreadyFoundMigratoryAttribute = false)
#foreach ($attribute in $entity.sortedClassAttributes)
#if ($attribute.userInfo.needsMigration && !$alreadyFoundMigratoryAttribute)
#if ($alreadyFoundMutableAttribute)    ,#else    implements#end org.webcat.core.MigratoryAttributeOwner
#set ($alreadyFoundMigratoryAttribute = true)
#end
#end
{
    //~ Constructors ..........................................................

    // ----------------------------------------------------------
    /**
     * Creates a new ${entity.prefixClassNameWithoutPackage} object.
     */
    public ${entity.prefixClassNameWithoutPackage}()
    {
        super();
    }


#if (!$entity.abstractEntity)
    // ----------------------------------------------------------
    /**
     * A static factory method for creating a new
     * ${entity.classNameWithoutPackage} object given required
     * attributes and relationships.
     * @param editingContext The context in which the new object will be
     * inserted
#foreach ($attribute in $entity.sortedClassAttributes)
#if (!$attribute.allowsNull)
     * @param ${attribute.name}Value
#end
#end
#foreach ($relationship in $entity.sortedClassToOneRelationships)
#if ($relationship.mandatory)
     * @param ${relationship.name}Value
#end
#end
     * @return The newly created object
     */
    public static ${entity.classNameWithoutPackage} create(
        EOEditingContext editingContext#foreach ($attribute in $entity.sortedClassAttributes)#if (!$attribute.allowsNull),
        #if ($attribute.userInfo.isScalar || $attribute.userInfo.isEnum)${attribute.userInfo.type}#else${attribute.javaClassName}#end ${attribute.name}Value#end
#end#foreach ($relationship in $entity.sortedClassToOneRelationships)#if ($relationship.mandatory),
        ${relationship.actualDestination.classNameWithDefault} ${relationship.name}Value#end#end

        )
    {
        ${entity.classNameWithoutPackage} eoObject = (${entity.classNameWithoutPackage})
            EOUtilities.createAndInsertInstance(
                editingContext,
                ${entity.prefixClassNameWithoutPackage}.ENTITY_NAME);
#foreach ($attribute in $entity.sortedClassAttributes)
#if (!$attribute.allowsNull)
        eoObject.set${attribute.capitalizedName}(${attribute.name}Value);
#end
#end
#foreach ($relationship in $entity.sortedClassToOneRelationships)
#if ($relationship.mandatory)
        eoObject.set${relationship.capitalizedName}Relationship(${relationship.name}Value);
#end
#end
        return eoObject;
    }


    // ----------------------------------------------------------
    /**
     * Get a local instance of the given object in another editing context.
     * @param editingContext The target editing context
     * @param eo The object to import
     * @return An instance of the given object in the target editing context
     */
    public static ${entity.classNameWithoutPackage} localInstance(
        EOEditingContext editingContext, ${entity.classNameWithoutPackage} eo)
    {
        return (eo == null)
            ? null
            : (${entity.classNameWithoutPackage})EOUtilities.localInstanceOfObject(
                editingContext, eo);
    }


    // ----------------------------------------------------------
    /**
     * Look up an object by id number.  Assumes the editing
     * context is appropriately locked.
     * @param ec The editing context to use
     * @param id The id to look up
     * @return The object, or null if no such id exists
     */
    public static ${entity.classNameWithoutPackage} forId(
        EOEditingContext ec, int id)
    {
        ${entity.classNameWithoutPackage} obj = null;
        if (id > 0)
        {
            NSArray<${entity.classNameWithoutPackage}> objects =
                objectsMatchingValues(ec, "id", new Integer(id));
            if (objects != null && objects.count() > 0)
            {
                obj = objects.objectAtIndex(0);
            }
        }
        return obj;
    }


    // ----------------------------------------------------------
    /**
     * Look up an object by id number.  Assumes the editing
     * context is appropriately locked.
     * @param ec The editing context to use
     * @param id The id to look up
     * @return The object, or null if no such id exists
     */
    public static ${entity.classNameWithoutPackage} forId(
        EOEditingContext ec, String id)
    {
        return forId(ec, er.extensions.foundation.ERXValueUtilities.intValue(id));
    }


#end
    //~ Constants (for key names) .............................................
#*

  Some people like to have constant strings defined for each key. For an
  attribute named fooBar, this will declare a FOO_BAR_KEY constant string.

*#
#if ($entity.abstractEntity)
    // Relationship to base slice ---
    private static final String BASE_PREFIX = "${entity.initialLowercaseName}";
    private static final String BASE_PREFIX_DOT = BASE_PREFIX + ".";
#end
    // Attributes ---
#foreach ($attribute in $entity.sortedClassAttributes)
#if (!$attribute.inherited)
#if (!$entity.abstractEntity)
    public static final String ${attribute.uppercaseUnderscoreName}_KEY = "${attribute.name}";
#else
    public static final String ${attribute.uppercaseUnderscoreName}_KEY = BASE_PREFIX_DOT + "${attribute.name$}";
#end
    public static final ERXKey<${attribute.javaClassName}> ${attribute.name} =
        new ERXKey<${attribute.javaClassName}>(${attribute.uppercaseUnderscoreName}_KEY);
#end
#end
    // To-one relationships ---
#foreach ($rel in $entity.sortedClassToOneRelationships)
#if (!$rel.inherited)
#if (!$entity.abstractEntity)
    public static final String ${rel.uppercaseUnderscoreName}_KEY = "${rel.name}";
#else
    public static final String ${rel.uppercaseUnderscoreName}_KEY = BASE_PREFIX_DOT + "${rel.name}";
#end
    public static final ERXKey<${rel.actualDestination.classNameWithDefault}> ${rel.name} =
        new ERXKey<${rel.actualDestination.classNameWithDefault}>(${rel.uppercaseUnderscoreName}_KEY);
#end
#end
    // To-many relationships ---
#foreach ($rel in $entity.sortedClassToManyRelationships)
#if (!$rel.inherited)
#if (!$entity.abstractEntity)
    public static final String ${rel.uppercaseUnderscoreName}_KEY = "${rel.name}";
#else
    public static final String ${rel.uppercaseUnderscoreName}_KEY = BASE_PREFIX_DOT + "${rel.name}";
#end
    public static final ERXKey<${rel.actualDestination.classNameWithDefault}> ${rel.name} =
        new ERXKey<${rel.actualDestination.classNameWithDefault}>(${rel.uppercaseUnderscoreName}_KEY);
#end
#end
    // Fetch specifications ---
#foreach ($fetchSpec in $entity.sortedFetchSpecs)
    public static final String ${fetchSpec.uppercaseUnderscoreName}_FSPEC = "${fetchSpec.name}";
#end
#if (!$entity.abstractEntity)
    public static final String ENTITY_NAME = "${entity.name}";
#end

    public transient final EOBasedKeyGenerator generateKey =
        new EOBasedKeyGenerator(this);


    //~ Methods ...............................................................

    // ----------------------------------------------------------
    /**
     * Get a local instance of this object in another editing context.
     * @param editingContext The target editing context
     * @return An instance of this object in the target editing context
     */
    public ${entity.classNameWithoutPackage} localInstance(EOEditingContext editingContext)
    {
        return (${entity.classNameWithoutPackage})EOUtilities.localInstanceOfObject(
            editingContext, this);
    }


#if (!$entity.parentSet)
    // ----------------------------------------------------------
    /**
     * Get a list of changes between this object's current state and the
     * last committed version.
     * @return a dictionary of the changes that have not yet been committed
     */
    @SuppressWarnings("unchecked")
    public NSDictionary<String, Object> changedProperties()
    {
        return changesFromSnapshot(
            editingContext().committedSnapshotForObject(this));
    }


    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code>id</code> value.
     * @return the value of the attribute
     */
    public Number id()
    {
        try
        {
            return (Number)EOUtilities.primaryKeyForObject(
                editingContext() , this).objectForKey("id");
        }
        catch (Exception e)
        {
            return er.extensions.eof.ERXConstant.ZeroInteger;
        }
    }

#end## entity.parentSet
#foreach ($attribute in $entity.sortedClassAttributes)
#if (!$attribute.inherited)
#if ($attribute.userInfo.isMutable)
    //-- Local mutable cache --
    private ${attribute.userInfo.valueClassName} ${attribute.name}Cache;
    private ${attribute.javaClassName} ${attribute.name}RawCache;

    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code>${attribute.name}</code> value.
     * @return the value of the attribute
     */
    public ${attribute.userInfo.valueClassName} ${attribute.name}()
    {
        ${attribute.javaClassName} dbValue =
            (${attribute.javaClassName})storedValueForKey("${attribute.name}");
        if (${attribute.name}RawCache != dbValue)
        {
            if (dbValue != null && dbValue.equals( ${attribute.name}RawCache))
            {
                // They are still equal, so just update the raw cache
                ${attribute.name}RawCache = dbValue;
            }
            else
            {
                // Underlying attribute may have changed because
                // of a concurrent update through another editing
                // context, so throw away current values.
                ${attribute.name}RawCache = dbValue;
                ${attribute.userInfo.valueClassName} newValue =
                    ${attribute.userInfo.valueClassName}
                    .${attribute.userInfo.valueFactoryMethodName}( dbValue );
                if ( ${attribute.name}Cache != null )
                {
                    ${attribute.name}Cache.copyFrom( newValue );
                }
                else
                {
                    ${attribute.name}Cache = newValue;
                }
                ${attribute.name}Cache.setOwner( this );
                setUpdateMutableFields( true );
            }
        }
        else if ( dbValue == null && ${attribute.name}Cache == null )
        {
            ${attribute.name}Cache =
                ${attribute.userInfo.valueClassName}
                .${attribute.userInfo.valueFactoryMethodName}( dbValue );
             ${attribute.name}Cache.setOwner( this );
             setUpdateMutableFields( true );
        }
        return ${attribute.name}Cache;
    }


    // ----------------------------------------------------------
    /**
     * Change the value of this object's <code>${attribute.name}</code>
     * property.
     *
     * @param value The new value for this property
     */
    public void set${attribute.capitalizedName}( ${attribute.userInfo.valueClassName} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${attribute.capitalizedName}("
                + value + ")" );
        }
        if ( ${attribute.name}Cache == null )
        {
            ${attribute.name}Cache = value;
            value.setHasChanged( false );
            ${attribute.name}RawCache = value.${attribute.userInfo.adaptorValueConversionMethodName}();
            takeStoredValueForKey( ${attribute.name}RawCache, "${attribute.name}" );
        }
        else if ( ${attribute.name}Cache != value )  // ( ${attribute.name}Cache != null )
        {
            ${attribute.name}Cache.copyFrom( value );
            setUpdateMutableFields( true );
        }
        else  // ( ${attribute.name}Cache == non-null value )
        {
            // no nothing
        }
    }


    // ----------------------------------------------------------
    /**
     * Clear the value of this object's <code>${attribute.name}</code>
     * property.
     */
    public void clear${attribute.capitalizedName}()
    {
        if (log.isDebugEnabled())
        {
            log.debug( "clear${attribute.capitalizedName}()" );
        }
        takeStoredValueForKey( null, "${attribute.name}" );
        ${attribute.name}RawCache = null;
        ${attribute.name}Cache = null;
    }


#else## !isMutable
#if ($attribute.userInfo.isScalar)
#set ($attributeNeedsRaw = true)
    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code>${attribute.name}</code> value.
     * @return the value of the attribute
     */
    public ${attribute.userInfo.type} ${attribute.name}()
    {
        ${attribute.javaClassName} returnValue =
            (${attribute.javaClassName})storedValueForKey( "${attribute.name}" );
        return ( returnValue == null )
            ? ${attribute.userInfo.scalarDefault}
            : #if ($attribute.userInfo.type eq "boolean")( returnValue.intValue() > 0 )#{else}returnValue.${attribute.userInfo.scalarConversionMethodName}()#{end};
    }


    // ----------------------------------------------------------
    /**
     * Change the value of this object's <code>${attribute.name}</code>
     * property.
     *
     * @param value The new value for this property
     */
    public void set${attribute.capitalizedName}( ${attribute.userInfo.type} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${attribute.capitalizedName}("
                + value + "): was " + ${attribute.name}() );
        }
        ${attribute.javaClassName} actual =
#if ($attribute.userInfo.type eq "boolean")
            er.extensions.eof.ERXConstant.integerForInt( value ? 1 : 0 );
#elseif ($attribute.userInfo.type eq "int"
      || $attribute.userInfo.type eq "byte"
      || $attribute.userInfo.type eq "short")
            er.extensions.eof.ERXConstant.integerForInt( value );
#else
            new ${attribute.userInfo.valueClassName}( value );
#end
            set${attribute.capitalizedName}Raw( actual );
    }


#elseif ($attribute.userInfo.isEnum)
#set ($attributeNeedsRaw = true)
    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code>${attribute.name}</code> value.
     * @return the value of the attribute
     */
    public ${attribute.userInfo.type} ${attribute.name}()
    {
        ${attribute.javaClassName} returnValue =
            (${attribute.javaClassName})storedValueForKey( "${attribute.name}" );
        return ( returnValue == null )
            ? ${attribute.userInfo.type}.${attribute.userInfo.enumDefault}
            : ${attribute.userInfo.type}.valueOf(returnValue);
    }


    // ----------------------------------------------------------
    /**
     * Change the value of this object's <code>${attribute.name}</code>
     * property.
     *
     * @param value The new value for this property
     */
    public void set${attribute.capitalizedName}( ${attribute.userInfo.type} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${attribute.capitalizedName}("
                + "${attribute.userInfo.type}." + value
                + "): was ${attribute.userInfo.type}."
                + ${attribute.name}().name() );
        }
        set${attribute.capitalizedName}Raw( value.name() );
    }


#else
#set ($attributeNeedsRaw = false)
#end## isScalar
    // ----------------------------------------------------------
    /**
     * Retrieve this object's <code>${attribute.name}</code> value.
     * @return the value of the attribute
     */
    public ${attribute.javaClassName} ${attribute.name}#if ($attributeNeedsRaw)Raw#{end}()
    {
        return (${attribute.javaClassName})storedValueForKey( "${attribute.name}" );
    }


    // ----------------------------------------------------------
    /**
     * Change the value of this object's <code>${attribute.name}</code>
     * property.
     *
     * @param value The new value for this property
     */
    public void set${attribute.capitalizedName}#if ($attributeNeedsRaw)Raw#{end}( ${attribute.javaClassName} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${attribute.capitalizedName}#if ($attributeNeedsRaw)Raw#{end}("
                + value + "): was " + ${attribute.name}#if ($attributeNeedsRaw)Raw#{end}() );
        }
        takeStoredValueForKey( value, "${attribute.name}" );
    }


#end## is or is not mutable
#end## !inherited
#end## for entity.sortedClassAttributes
#set ($alreadyFoundMutableAttribute = false)
#foreach ($attribute in $entity.sortedClassAttributes)## has mutables
#if ($attribute.userInfo.isMutable && !$alreadyFoundMutableAttribute)
#set ($alreadyFoundMutableAttribute = true)
    // ----------------------------------------------------------
    /**
     * Called just before this object is saved to the database.
     */
    public void saveMutables()
    {
        log.debug("saveMutables()");
#foreach ($attribute in $entity.sortedClassAttributes)## willUpdate
#if ($attribute.userInfo.isMutable)
        if ( ${attribute.name}Cache != null
            && ${attribute.name}Cache.hasChanged() )
        {
            ${attribute.name}RawCache = ${attribute.name}Cache.${attribute.userInfo.adaptorValueConversionMethodName}();
            takeStoredValueForKey( ${attribute.name}RawCache, "${attribute.name}" );
            ${attribute.name}Cache.setHasChanged( false );
        }
#end
#end## willUpdate

        setUpdateMutableFields( false );
    }


    // ----------------------------------------------------------
    /**
     * Called just before this object is saved to the database.
     */
    public void willUpdate()
    {
        log.debug("willUpdate()");
        saveMutables();
        super.willUpdate();
    }


    // ----------------------------------------------------------
    /**
     * Called just before this object is inserted into the database.
     */
    public void willInsert()
    {
        log.debug("willInsert()");
        saveMutables();
        super.willInsert();
    }


    // ----------------------------------------------------------
    /**
     * Called when the object is invalidated.
     */
    public void flushCaches()
    {
        log.debug("flushCaches()");
#foreach ($attribute in $entity.sortedClassAttributes)## flushCache
#if ($attribute.userInfo.isMutable)
        ${attribute.name}Cache = null;
        ${attribute.name}RawCache  = null;
#end
#end## flushCache
        super.flushCaches();
    }


    // ----------------------------------------------------------
    /**
     * Called when an owned mutable container object is changed.
     */
    public void mutableContainerHasChanged()
    {
        setUpdateMutableFields( true );
    }


#end
#end## has mutables
#set ($alreadyFoundMigratoryAttribute = false)
#foreach ($attribute in $entity.sortedClassAttributes)## has migratory attributes
#if (!$attribute.inherited)
#if ($attribute.userInfo.needsMigration && !$alreadyFoundMigratoryAttribute)
#set ($alreadyFoundMigratoryAttribute = true)
    // ----------------------------------------------------------
    @Override
    public void awakeFromFetch(EOEditingContext ec)
    {
        super.awakeFromFetch(ec);

        // Only try to migrate if the EC isn't a migrating context. If it is,
        // we're already trying to migrate and this "awake" is coming from the
        // child migration context.

        if (!(ec instanceof org.webcat.woextensions.MigratingEditingContext))
        {
            migrateAttributeValuesIfNeeded();
        }
    }


    // ----------------------------------------------------------
    /**
     * Called by {@link #awake} to migrate attribute values if needed when the
     * object is retrieved.
     */
    public final void migrateAttributeValuesIfNeeded()
    {
        log.debug("migrateAttributeValuesIfNeeded()");

#set ($alreadyFoundOneMigratoryAttribute = false)
        if ( #foreach ($attribute in $entity.sortedClassAttributes)
#if ($attribute.userInfo.needsMigration)
#if ($alreadyFoundOneMigratoryAttribute)

            || #end
shouldMigrate${attribute.capitalizedName}()#set ($alreadyFoundOneMigratoryAttribute = true)
#end
#end )
        {
            new org.webcat.woextensions.ECAction(
                org.webcat.woextensions.MigratingEditingContext
                    .newEditingContext())
            {
                public void action()
                {
                    migrateAttributeValues(
                        (org.webcat.woextensions.MigratingEditingContext)ec,
                        localInstance(ec));
                    ec.saveChanges();
                }
            }.run();
        }
    }


    // ----------------------------------------------------------
    /**
     * Called by {@link #awake} to migrate attribute values when the
     * object is retrieved.
     */
    protected void migrateAttributeValues(
        org.webcat.woextensions.MigratingEditingContext mec,
        ${entity.classNameWithoutPackage} migratingObject
    )
    {
        log.debug("migrateAttributeValues()");

#foreach ($attribute in $entity.sortedClassAttributes)
#if ($attribute.userInfo.needsMigration)
        if ( migratingObject.shouldMigrate${attribute.capitalizedName}() )
        {
            migratingObject.migrate${attribute.capitalizedName}(mec);
        }
#end
#end
    }


#foreach ($attribute in $entity.sortedClassAttributes)
#if ($attribute.userInfo.needsMigration)
    // ----------------------------------------------------------
    /**
     * Called by {@link #migrateAttributeValues} to migrate the
     * ${attribute.name} attribute.
     */
    protected abstract boolean shouldMigrate${attribute.capitalizedName}();


    // ----------------------------------------------------------
    /**
     * Called by {@link #migrateAttributeValues} to migrate the
     * ${attribute.name} attribute.
     */
    protected abstract void migrate${attribute.capitalizedName}(
        org.webcat.woextensions.MigratingEditingContext mec);


#end
#end
#end
#end
#end## has migratory attributes
#*
   Add methods to call named fetch specifications, with any qualifier bindings
   having typed parameters.

*##foreach ($relationship in $entity.sortedClassToOneRelationships)## toonerels
#if (!$relationship.inherited)
    // ----------------------------------------------------------
    /**
     * Retrieve the entity pointed to by the <code>${relationship.name}</code>
     * relationship.
     * @return the entity in the relationship
     */
    public ${relationship.actualDestination.classNameWithDefault} ${relationship.name}()
    {
        return (${relationship.actualDestination.classNameWithDefault})storedValueForKey( "${relationship.name}" );
    }


    // ----------------------------------------------------------
    /**
     * Set the entity pointed to by the <code>${relationship.name}</code>
     * relationship (DO NOT USE--instead, use
     * <code>set${relationship.capitalizedName}Relationship()</code>.
     * This method is provided for WebObjects use.
     *
     * @param value The new entity to relate to
     */
    public void set${relationship.capitalizedName}( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${relationship.capitalizedName}("
                + value + "): was " + ${relationship.name}() );
        }
        takeStoredValueForKey( value, "${relationship.name}" );
    }

#*
   The following method is better than using addObjectToBothSidesOf-
   RelationshipWithKey directly because you will get compile time type
   checking instead of runtime checking (plus you don't risk typos in
   constant strings of key names).
*#
    // ----------------------------------------------------------
    /**
     * Set the entity pointed to by the <code>${relationship.name}</code>
     * relationship.  This method is a type-safe version of
     * <code>addObjectToBothSidesOfRelationshipWithKey()</code>.
     *
     * @param value The new entity to relate to
     */
    public void set${relationship.capitalizedName}Relationship(
        ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${relationship.capitalizedName}Relationship("
                + value + "): was " + ${relationship.name}() );
        }
        if ( value == null )
        {
            ${relationship.actualDestination.classNameWithDefault} object = ${relationship.name}();
            if ( object != null )
                removeObjectFromBothSidesOfRelationshipWithKey( object, "${relationship.name}" );
        }
        else
        {
            addObjectToBothSidesOfRelationshipWithKey( value, "${relationship.name}" );
        }
    }


#end## !inherited
#end## toonerels
#foreach ($relationship in $entity.sortedClassToManyRelationships)## tomanyrels
#if (!$relationship.inherited)
    // ----------------------------------------------------------
    /**
     * Retrieve the entities pointed to by the <code>${relationship.name}</code>
     * relationship.
     * @return an NSArray of the entities in the relationship
     */
    @SuppressWarnings("unchecked")
    public NSArray<${relationship.actualDestination.classNameWithDefault}> ${relationship.name}()
    {
        return (NSArray)storedValueForKey( "${relationship.name}" );
    }


    // ----------------------------------------------------------
    /**
     * Replace the list of entities pointed to by the
     * <code>${relationship.name}</code> relationship.
     *
     * @param value The new set of entities to relate to
     */
    public void set${relationship.capitalizedName}( NSMutableArray<${relationship.actualDestination.classNameWithDefault}>  value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "set${relationship.capitalizedName}("
                + value + "): was " + ${relationship.name}() );
        }
        takeStoredValueForKey( value, "${relationship.name}" );
    }


    // ----------------------------------------------------------
    /**
     * Add a new entity to the <code>${relationship.name}</code>
     * relationship (DO NOT USE--instead, use
     * <code>addTo${relationship.capitalizedName}Relationship()</code>.
     * This method is provided for WebObjects use.
     *
     * @param value The new entity to relate to
     */
    public void addTo${relationship.capitalizedName}( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "addTo${relationship.capitalizedName}("
                + value + "): was " + ${relationship.name}() );
        }
        NSMutableArray<${relationship.actualDestination.classNameWithDefault}> array =
            (NSMutableArray<${relationship.actualDestination.classNameWithDefault}>)${relationship.name}();
        willChange();
        array.addObject( value );
    }


    // ----------------------------------------------------------
    /**
     * Remove a specific entity from the <code>${relationship.name}</code>
     * relationship (DO NOT USE--instead, use
     * <code>removeFrom${relationship.capitalizedName}Relationship()</code>.
     * This method is provided for WebObjects use.
     *
     * @param value The entity to remove from the relationship
     */
    public void removeFrom${relationship.capitalizedName}( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "RemoveFrom${relationship.capitalizedName}("
                + value + "): was " + ${relationship.name}() );
        }
        NSMutableArray<${relationship.actualDestination.classNameWithDefault}> array =
            (NSMutableArray<${relationship.actualDestination.classNameWithDefault}>)${relationship.name}();
        willChange();
        array.removeObject( value );
    }

#*
   The following adds typed methods to add or remove an object from a to-many
   relationship. This is better than using addObjectToBothSidesOfRelationship-
   WithKey directly because you will get compile time type checking instead of
   runtime checking, and you avoid the possibility of making a typo in the key
   name.
*#
    // ----------------------------------------------------------
    /**
     * Add a new entity to the <code>${relationship.name}</code>
     * relationship.
     *
     * @param value The new entity to relate to
     */
    public void addTo${relationship.capitalizedName}Relationship( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "addTo${relationship.capitalizedName}Relationship("
                + value + "): was " + ${relationship.name}() );
        }
        addObjectToBothSidesOfRelationshipWithKey(
            value, "${relationship.name}" );
    }


    // ----------------------------------------------------------
    /**
     * Remove a specific entity from the <code>${relationship.name}</code>
     * relationship.
     *
     * @param value The entity to remove from the relationship
     */
    public void removeFrom${relationship.capitalizedName}Relationship( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "removeFrom${relationship.capitalizedName}Relationship("
                + value + "): was " + ${relationship.name}() );
        }
        removeObjectFromBothSidesOfRelationshipWithKey(
            value, "${relationship.name}" );
    }

#*
   The following adds typed methods to create, and delete objects from a to-
   many relationship. The main difference in the delete mechanism, versus the
   removeFrom... method above is that this delete method will remove the object
   from the editing context if it is we do not own its destination.  The user
   can override these methods in the subclass to provide additional
   functionality on these methods.
*#
    // ----------------------------------------------------------
    /**
     * Create a brand new object that is a member of the
     * <code>${relationship.name}</code> relationship.
     *
     * @return The new entity
     */
    public ${relationship.actualDestination.classNameWithDefault} create${relationship.capitalizedName}Relationship()
    {
        if (log.isDebugEnabled())
        {
            log.debug( "create${relationship.capitalizedName}Relationship()" );
        }
        EOClassDescription eoClassDesc = EOClassDescription
            .classDescriptionForEntityName( "${relationship.actualDestination.name}" );
        EOEnterpriseObject eoObject = eoClassDesc
            .createInstanceWithEditingContext( editingContext(), null );
        editingContext().insertObject( eoObject );
        addObjectToBothSidesOfRelationshipWithKey(
            eoObject, "${relationship.name}" );
        return (${relationship.actualDestination.classNameWithDefault})eoObject;
    }


    // ----------------------------------------------------------
    /**
     * Remove#if (!$relationship.ownsDestination) and then delete#end a specific entity that is a member of the
     * <code>${relationship.name}</code> relationship.
     *
     * @param value The entity to remove from the relationship#if (!$relationship.ownsDestination) and then delete#end

     */
    public void delete${relationship.capitalizedName}Relationship( ${relationship.actualDestination.classNameWithDefault} value )
    {
        if (log.isDebugEnabled())
        {
            log.debug( "delete${relationship.capitalizedName}Relationship("
                + value + "): was " + ${relationship.name}() );
        }
        removeObjectFromBothSidesOfRelationshipWithKey(
            value, "${relationship.name}" );
#if (!$relationship.ownsDestination)
        editingContext().deleteObject( value );
#end
    }


    // ----------------------------------------------------------
    /**
     * Remove (and then delete, if owned) all entities that are members of the
     * <code>${relationship.name}</code> relationship.
     */
    public void deleteAll${relationship.capitalizedName}Relationships()
    {
        if (log.isDebugEnabled())
        {
            log.debug( "deleteAll${relationship.capitalizedName}Relationships(): was "
                + ${relationship.name}() );
        }
        for (${relationship.actualDestination.classNameWithDefault} object : ${relationship.name}())
        {
            delete${relationship.capitalizedName}Relationship(object);
        }
    }


#end## !inherited
#end## tomanyrels
#if (!$entity.abstractEntity)
    // ----------------------------------------------------------
    /**
     * Retrieve objects using a fetch specification.
     *
     * @param context The editing context to use
     * @param fspec The fetch specification to use
     *
     * @return an NSArray of the entities retrieved
     */
    @SuppressWarnings("unchecked")
    public static NSArray<${entity.classNameWithoutPackage}> objectsWithFetchSpecification(
        EOEditingContext context,
        EOFetchSpecification fspec)
    {
        return context.objectsWithFetchSpecification(fspec);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve all objects of this type.
     *
     * @param context The editing context to use
     *
     * @return an NSArray of the entities retrieved
     */
    public static NSArray<${entity.classNameWithoutPackage}> allObjects(
        EOEditingContext context)
    {
        return objectsMatchingQualifier(context, null, null);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve objects using a qualifier.
     *
     * @param context The editing context to use
     * @param qualifier The qualifier to use
     *
     * @return an NSArray of the entities retrieved
     */
    public static NSArray<${entity.classNameWithoutPackage}> objectsMatchingQualifier(
        EOEditingContext context,
        EOQualifier qualifier)
    {
        return objectsMatchingQualifier(context, qualifier, null);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve objects using a qualifier and sort orderings.
     *
     * @param context The editing context to use
     * @param qualifier The qualifier to use
     * @param sortOrderings The sort orderings to use
     *
     * @return an NSArray of the entities retrieved
     */
    public static NSArray<${entity.classNameWithoutPackage}> objectsMatchingQualifier(
        EOEditingContext context,
        EOQualifier qualifier,
        NSArray<EOSortOrdering> sortOrderings)
    {
        @SuppressWarnings("unchecked")
        EOFetchSpecification fspec = new WCFetchSpecification(
                ENTITY_NAME, qualifier, sortOrderings);
        fspec.setUsesDistinct(true);
        return objectsWithFetchSpecification(context, fspec);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve the first object that matches a qualifier, when
     * sorted with the specified sort orderings.
     *
     * @param context The editing context to use
     * @param qualifier The qualifier to use
     * @param sortOrderings the sort orderings
     *
     * @return the first entity that was retrieved, or null if there was none
     */
    public static ${entity.classNameWithoutPackage} firstObjectMatchingQualifier(
        EOEditingContext context,
        EOQualifier qualifier,
        NSArray<EOSortOrdering> sortOrderings)
    {
        NSArray<${entity.classNameWithoutPackage}> objects =
            objectsMatchingQualifier(context, qualifier, sortOrderings);
        return (objects.size() > 0)
            ? objects.get(0)
            : null;
    }


    // ----------------------------------------------------------
    /**
     * Retrieve a single object using a list of keys and values to match.
     *
     * @param context The editing context to use
     * @param qualifier The qualifier to use
     *
     * @return the single entity that was retrieved
     *
     * @throws EOUtilities.MoreThanOneException
     *     if there is more than one matching object
     */
    public static ${entity.classNameWithoutPackage} uniqueObjectMatchingQualifier(
        EOEditingContext context,
        EOQualifier qualifier) throws EOUtilities.MoreThanOneException
    {
        NSArray<${entity.classNameWithoutPackage}> objects =
            objectsMatchingQualifier(context, qualifier);
        if (objects.size() > 1)
        {
            String msg = "fetching ${entity.classNameWithoutPackage}";
            try
            {
                if (qualifier != null)
                {
                    msg += " where " + qualifier;
                }
                msg += ", result = " + objects;
            }
            catch (Exception e)
            {
                log.error("Exception building MoreThanOneException message, "
                    + "contents so far: " + msg, e);
            }
            throw new EOUtilities.MoreThanOneException(msg);
        }
        return (objects.size() > 0)
            ? objects.get(0)
            : null;
    }


    // ----------------------------------------------------------
    /**
     * Retrieve objects using a list of keys and values to match.
     *
     * @param context The editing context to use
     * @param keysAndValues a list of keys and values to match, alternating
     *     "key", "value", "key", "value"...
     *
     * @return an NSArray of the entities retrieved
     */
    public static NSArray<${entity.classNameWithoutPackage}> objectsMatchingValues(
        EOEditingContext context,
        Object... keysAndValues)
    {
        if (keysAndValues.length % 2 != 0)
        {
            throw new IllegalArgumentException("There should a value "
                + "corresponding to every key that was passed. Args = "
                + java.util.Arrays.toString(keysAndValues));
        }

        NSMutableDictionary<String, Object> valueDictionary =
            new NSMutableDictionary<String, Object>();

        for (int i = 0; i < keysAndValues.length; i += 2)
        {
            Object key = keysAndValues[i];
            Object value = keysAndValues[i + 1];

            if (key == null)
            {
                throw new IllegalArgumentException(
                    "Found null where a String key was expected, arguments = "
                    + java.util.Arrays.toString(keysAndValues));
            }
            else if (!(key instanceof String))
            {
                throw new IllegalArgumentException(
                    "Found a " + key.getClass().getName() + " [" + key + "]"
                    + " where a String key was expected, arguments = "
                    + java.util.Arrays.toString(keysAndValues));
            }

            valueDictionary.setObjectForKey(value, key);
        }

        return objectsMatchingValues(context, valueDictionary);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve objects using a dictionary of keys and values to match.
     *
     * @param context The editing context to use
     * @param keysAndValues a dictionary of keys and values to match
     *
     * @return an NSArray of the entities retrieved
     */
    @SuppressWarnings("unchecked")
    public static NSArray<${entity.classNameWithoutPackage}> objectsMatchingValues(
        EOEditingContext context,
        NSDictionary<String, Object> keysAndValues)
    {
        return EOUtilities.objectsMatchingValues(context, ENTITY_NAME,
            keysAndValues);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve the first object that matches a set of keys and values, when
     * sorted with the specified sort orderings.
     *
     * @param context The editing context to use
     * @param sortOrderings the sort orderings
     * @param keysAndValues a list of keys and values to match, alternating
     *     "key", "value", "key", "value"...
     *
     * @return the first entity that was retrieved, or null if there was none
     */
    public static ${entity.classNameWithoutPackage} firstObjectMatchingValues(
        EOEditingContext context,
        NSArray<EOSortOrdering> sortOrderings,
        Object... keysAndValues)
    {
        if (keysAndValues.length % 2 != 0)
        {
            throw new IllegalArgumentException("There should a value "
                + "corresponding to every key that was passed. Args = "
                + java.util.Arrays.toString(keysAndValues));
        }

        NSMutableDictionary<String, Object> valueDictionary =
            new NSMutableDictionary<String, Object>();

        for (int i = 0; i < keysAndValues.length; i += 2)
        {
            Object key = keysAndValues[i];
            Object value = keysAndValues[i + 1];

            if (key == null)
            {
                throw new IllegalArgumentException(
                    "Found null where a String key was expected, arguments = "
                    + java.util.Arrays.toString(keysAndValues));
            }
            else if (!(key instanceof String))
            {
                throw new IllegalArgumentException(
                    "Found a " + key.getClass().getName() + " [" + key + "]"
                    + " where a String key was expected, arguments = "
                    + java.util.Arrays.toString(keysAndValues));
            }

            valueDictionary.setObjectForKey(value, key);
        }

        return firstObjectMatchingValues(
            context, sortOrderings, valueDictionary);
    }


    // ----------------------------------------------------------
    /**
     * Retrieves the first object that matches a set of keys and values, when
     * sorted with the specified sort orderings.
     *
     * @param context The editing context to use
     * @param sortOrderings the sort orderings
     * @param keysAndValues a dictionary of keys and values to match
     *
     * @return the first entity that was retrieved, or null if there was none
     */
    public static ${entity.classNameWithoutPackage} firstObjectMatchingValues(
        EOEditingContext context,
        NSArray<EOSortOrdering> sortOrderings,
        NSDictionary<String, Object> keysAndValues)
    {
        @SuppressWarnings("unchecked")
        EOFetchSpecification fspec = new WCFetchSpecification(
                ENTITY_NAME,
                EOQualifier.qualifierToMatchAllValues(keysAndValues),
                sortOrderings);
        fspec.setFetchLimit(1);

        NSArray<${entity.classNameWithoutPackage}> objects =
            objectsWithFetchSpecification( context, fspec );

        if ( objects.count() == 0 )
        {
            return null;
        }
        else
        {
            return objects.objectAtIndex(0);
        }
    }


    // ----------------------------------------------------------
    /**
     * Retrieve a single object using a list of keys and values to match.
     *
     * @param context The editing context to use
     * @param keysAndValues a list of keys and values to match, alternating
     *     "key", "value", "key", "value"...
     *
     * @return the single entity that was retrieved, or null if there was none
     *
     * @throws EOUtilities.MoreThanOneException
     *     if there is more than one matching object
     */
    public static ${entity.classNameWithoutPackage} uniqueObjectMatchingValues(
        EOEditingContext context,
        Object... keysAndValues) throws EOUtilities.MoreThanOneException
    {
        if (keysAndValues.length % 2 != 0)
        {
            throw new IllegalArgumentException("There should a value "
                + "corresponding to every key that was passed. Args = "
                + java.util.Arrays.toString(keysAndValues));
        }

        NSMutableDictionary<String, Object> valueDictionary =
            new NSMutableDictionary<String, Object>();

        for (int i = 0; i < keysAndValues.length; i += 2)
        {
            Object key = keysAndValues[i];
            Object value = keysAndValues[i + 1];

            if (key == null)
            {
                throw new IllegalArgumentException(
                    "Found null where a String key was expected, arguments = "
                    + java.util.Arrays.toString(keysAndValues));
            }
            else if (!(key instanceof String))
            {
                throw new IllegalArgumentException(
                    "Found a " + key.getClass().getName() + " [" + key + "]"
                    + " where a String key was expected, arguments = "
                    + java.util.Arrays.toString(keysAndValues));
            }

            valueDictionary.setObjectForKey(value, key);
        }

        return uniqueObjectMatchingValues(context, valueDictionary);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve an object using a dictionary of keys and values to match.
     *
     * @param context The editing context to use
     * @param keysAndValues a dictionary of keys and values to match
     *
     * @return the single entity that was retrieved, or null if there was none
     *
     * @throws EOUtilities.MoreThanOneException
     *     if there is more than one matching object
     */
    public static ${entity.classNameWithoutPackage} uniqueObjectMatchingValues(
        EOEditingContext context,
        NSDictionary<String, Object> keysAndValues)
        throws EOUtilities.MoreThanOneException
    {
        try
        {
            return (${entity.classNameWithoutPackage})EOUtilities.objectMatchingValues(
                context, ENTITY_NAME, keysAndValues);
        }
        catch (EOObjectNotAvailableException e)
        {
            return null;
        }
    }


    // ----------------------------------------------------------
    /**
     * Retrieve the count of all objects of this type.
     *
     * @param context The editing context to use
     *
     * @return the count of all objects
     */
    public static int countOfAllObjects(EOEditingContext context)
    {
        return countOfObjectsMatchingQualifier(context, null);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve the count of objects that match a qualifier.
     *
     * @param context The editing context to use
     * @param qualifier The qualifier to use
     *
     * @return the count of objects matching the qualifier
     */
    public static int countOfObjectsMatchingQualifier(
        EOEditingContext context, EOQualifier qualifier)
    {
        return ERXEOControlUtilities.objectCountWithQualifier(
                context, ENTITY_NAME, qualifier);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve the count of objects using a list of keys and values to match.
     *
     * @param context The editing context to use
     * @param keysAndValues a list of keys and values to match, alternating
     *     "key", "value", "key", "value"...
     *
     * @return the count of objects that match the specified values
     */
    public static int countOfObjectsMatchingValues(
        EOEditingContext context,
        Object... keysAndValues)
    {
        if (keysAndValues.length % 2 != 0)
        {
            throw new IllegalArgumentException("There should a value "
                + "corresponding to every key that was passed. Args = "
                + java.util.Arrays.toString(keysAndValues));
        }

        NSMutableDictionary<String, Object> valueDictionary =
            new NSMutableDictionary<String, Object>();

        for (int i = 0; i < keysAndValues.length; i += 2)
        {
            Object key = keysAndValues[i];
            Object value = keysAndValues[i + 1];

            if (key == null)
            {
                throw new IllegalArgumentException(
                    "Found null where a String key was expected, arguments = "
                    + java.util.Arrays.toString(keysAndValues));
            }
            else if (!(key instanceof String))
            {
                throw new IllegalArgumentException(
                    "Found a " + key.getClass().getName() + " [" + key + "]"
                    + " where a String key was expected, arguments = "
                    + java.util.Arrays.toString(keysAndValues));
            }

            valueDictionary.setObjectForKey(value, key);
        }

        return countOfObjectsMatchingValues(context, valueDictionary);
    }


    // ----------------------------------------------------------
    /**
     * Retrieve the count of objects using a dictionary of keys and values to
     * match.
     *
     * @param context The editing context to use
     * @param keysAndValues a dictionary of keys and values to match
     *
     * @return the count of objects that matched the specified values
     */
    public static int countOfObjectsMatchingValues(
        EOEditingContext context,
        NSDictionary<String, Object> keysAndValues)
    {
        return countOfObjectsMatchingQualifier(context,
                EOQualifier.qualifierToMatchAllValues(keysAndValues));
    }


#foreach ($fetchSpec in $entity.sortedFetchSpecs)## fetchspec
#if ($fetchSpec.userInfo.ensureUnique)
    // ----------------------------------------------------------
    /**
     * Retrieve an object according to the <code>${fetchSpec.name}</code>
     * fetch specification. If more than one object is found, an exception is
     * thrown.
     *
     * @param context The editing context to use
#foreach ($binding in $fetchSpec.distinctBindings)
     * @param ${binding.name}Binding fetch spec parameter
#end
     * @return the object retrieved, or null if one was not found
     * @throws EOUtilities.MoreThanOneException if more than one object is found
     */
    public static ${entity.classNameWithoutPackage} ${fetchSpec.name}(
            EOEditingContext context#foreach ($binding in $fetchSpec.distinctBindings),
            ${binding.attributePath.childClassName} ${binding.name}Binding#end

        ) throws EOUtilities.MoreThanOneException
    {
        EOFetchSpecification spec = WCFetchSpecification
            .fetchSpecificationNamed("${fetchSpec.name}", "${entity.name}");
#if ($fetchSpec.distinctBindings.size() > 0)

        NSMutableDictionary<String, Object> bindings =
            new NSMutableDictionary<String, Object>();

#foreach ($binding in $fetchSpec.distinctBindings)
        if (${binding.name}Binding != null)
        {
            bindings.setObjectForKey(${binding.name}Binding,
                                     "${binding.name}");
        }
#end
        spec = spec.fetchSpecificationWithQualifierBindings(bindings);
#end

        NSArray<${entity.classNameWithoutPackage}> objects =
            objectsWithFetchSpecification(context, spec);
        if (log.isDebugEnabled())
        {
            log.debug( "${fetchSpec.name}(ec"
#foreach ($binding in $fetchSpec.distinctBindings)
                + ", " + ${binding.name}Binding
#end
                + "): " + objects );
        }

        if ( objects.count() == 0 )
        {
            return null;
        }
        else if ( objects.count() > 1 )
        {
            String msg = "fetching ${entity.classNameWithoutPackage} using ${fetchSpec.name}";
            try
            {
                if (bindings.size() != 0)
                {
                    msg += " where bindings = " + bindings;
                }
                msg += ", result = " + objects;
            }
            catch (Exception e)
            {
                log.error("Exception building MoreThanOneException message, "
                    + "contents so far: " + msg, e);
            }
            throw new EOUtilities.MoreThanOneException(msg);
        }
        else
        {
            return objects.objectAtIndex(0);
        }
    }


#elseif ($fetchSpec.fetchLimit == 1)
    // ----------------------------------------------------------
    /**
     * Retrieve an object according to the <code>${fetchSpec.name}</code>
     * fetch specification.
     *
     * @param context The editing context to use
#foreach ($binding in $fetchSpec.distinctBindings)
     * @param ${binding.name}Binding fetch spec parameter
#end
     * @return the object retrieved, or null if one was not found
     */
    public static ${entity.classNameWithoutPackage} ${fetchSpec.name}(
            EOEditingContext context#foreach ($binding in $fetchSpec.distinctBindings),
            ${binding.attributePath.childClassName} ${binding.name}Binding#end

        )
    {
        EOFetchSpecification spec = WCFetchSpecification
            .fetchSpecificationNamed("${fetchSpec.name}", "${entity.name}");
#if ($fetchSpec.distinctBindings.size() > 0)

        NSMutableDictionary<String, Object> bindings =
            new NSMutableDictionary<String, Object>();

#foreach ($binding in $fetchSpec.distinctBindings)
        if ( ${binding.name}Binding != null )
        {
            bindings.setObjectForKey( ${binding.name}Binding,
                                      "${binding.name}" );
        }
#end
        spec = spec.fetchSpecificationWithQualifierBindings( bindings );
#end

        NSArray<${entity.classNameWithoutPackage}> objects =
            objectsWithFetchSpecification( context, spec );
        if (log.isDebugEnabled())
        {
            log.debug( "${fetchSpec.name}(ec"
#foreach ($binding in $fetchSpec.distinctBindings)
                + ", " + ${binding.name}Binding
#end
                + "): " + objects );
        }

        if ( objects.count() == 0 )
        {
            return null;
        }
        else
        {
            return objects.objectAtIndex(0);
        }
    }


#else
    // ----------------------------------------------------------
    /**
     * Retrieve objects according to the <code>${fetchSpec.name}</code>
     * fetch specification.
     *
     * @param context The editing context to use
#foreach ($binding in $fetchSpec.distinctBindings)
     * @param ${binding.name}Binding fetch spec parameter
#end
     * @return an NSArray of the entities retrieved
     */
    public static NSArray<${entity.classNameWithoutPackage}> ${fetchSpec.name}(
            EOEditingContext context#foreach ($binding in $fetchSpec.distinctBindings),
            ${binding.attributePath.childClassName} ${binding.name}Binding#end)
    {
        EOFetchSpecification spec = WCFetchSpecification
            .fetchSpecificationNamed("${fetchSpec.name}", "${entity.name}");
#if ($fetchSpec.distinctBindings.size() > 0)

        NSMutableDictionary<String, Object> bindings =
            new NSMutableDictionary<String, Object>();

#foreach ($binding in $fetchSpec.distinctBindings)
        if (${binding.name}Binding != null)
        {
            bindings.setObjectForKey(${binding.name}Binding,
                                     "${binding.name}");
        }
#end
        spec = spec.fetchSpecificationWithQualifierBindings(bindings);
#end

        NSArray<${entity.classNameWithoutPackage}> objects =
            objectsWithFetchSpecification(context, spec);
        if (log.isDebugEnabled())
        {
            log.debug("${fetchSpec.name}(ec"
#foreach ($binding in $fetchSpec.distinctBindings)
                + ", " + ${binding.name}Binding
#end
                + "): " + objects);
        }
        return objects;
    }


#end## fetchspec.fetchLimit
#end## fetchspec
#end
    // ----------------------------------------------------------
    /**
     * Produce a string representation of this object.  This implementation
     * calls UserPresentableDescription(), which uses WebObjects' internal
     * mechanism to print out the visible fields of this object.  Normally,
     * subclasses would override userPresentableDescription() to change
     * the way the object is printed.
     *
     * @return A string representation of the object's value
     */
    public String toString()
    {
        return userPresentableDescription();
    }

#if ($entity.abstractEntity)

    // ----------------------------------------------------------
    /**
     * Hack to workaround the need to include the base relationship when
     * fetching objects vs. getting/setting their values via KVC.
     *
     * @param key the key to access
     * @return the value of the key
     */
    public Object valueForKey(String key)
    {
        if (key.equals(BASE_PREFIX))
        {
            return this;
        }

        if (key.startsWith(BASE_PREFIX_DOT))
        {
            key = key.substring(BASE_PREFIX_DOT.length());
        }

        return super.valueForKey(key);
    }


    // ----------------------------------------------------------
    /**
     * Hack to workaround the need to include the base relationship when
     * fetching objects vs. getting/setting their values via KVC.
     *
     * @param value the new value of the key
     * @param key the key to access
     */
    public void takeValueForKey(Object value, String key)
    {
        if (key.startsWith(BASE_PREFIX_DOT))
        {
            key = key.substring(BASE_PREFIX_DOT.length());
        }

        super.takeValueForKey(value, key);
    }

#end

    //~ Instance/static variables .............................................

    static Logger log = Logger.getLogger(${entity.classNameWithoutPackage}.class);
}
